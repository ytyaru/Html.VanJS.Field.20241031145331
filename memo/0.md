# Field

<!-- more -->

```javascript
const name = new Field('name', 'Type', 'value', true)
```
```javascript
const name = new Field({
    key: 'key',      // key or name
    name: 'name',
    type: 'String',
    value: 'value',
    nullable: false
    mutable: false,
})
```
```javascript
name.n // 'name'
name.k // 'key'
name.t // 'String'
name.v // 'value'
name.n // nullable(true/false)
name.m // mutable(true/false)
```
```javascript
name.v = 'x' // OK
name.n = 'y' // TypeError: Read only
name.t = 'y' // TypeError: Read only
```
```javascript
name.x       // TypeError: Filedはn,t,vのみ参照可能です。（toString, hasもいる？）
```
```javascript
name.v = 0   // TypeError: Invalid type. String only.
```
```javascript
name.g // getter
name.s // setter

name.on.before
name.on.after
name.on.validate
name.on.valid
name.on.invalid
name.on.assign    // 代入する値を返す。但し()=>undefined だと代入しない。
name.on.change
name.on.unchange
```



# TypedValue / Field

　よく考えたら次の２パターンありうる。

* 単一の変数
* 他の変数やメソッドと協調する変数

　後者は`this`で他の変数、メソッド、ディスクリプタを参照できるべき。

型|概要
--|----
`TypedValue`|単一の変数
`Field`|`this`で他の変数やメソッドを参照可能


```javascript
const name = new Var('name', 'Type', 'value', true)
```
```javascript
const name = new Var({
    name: 'name',
    type: 'String',
    value: 'value',
    nullable: false
    mutable: true,
})
```
```javascript
name.n // 'name'
name.t // 'String'
name.v // 'value'
```
```javascript
name.v = 'x' // OK
name.n = 'y' // TypeError
name.t = 'y' // TypeError
```
```javascript
name.x       // TypeError: Filedはn,t,vのみ参照可能です。（toString, hasもいる？）
```

　`this`で自身が持つ他の変数や関数を参照できる。

```javascript
const Human = new Class(
    name: new Field('String', '', false,
        ()=>`${this.firstName} ${this.lastName}`,
        (v)=>[this.firstName,this.lastName]=v.split(' ')), 
    firstName : new Field('String', '', false), 
    lastName : new Field('String', '', false), 
    age: new Field('Integer', 0, true), 
    weight: new Field('Float', 0.0, true), 
    intro: ()=>`My name is ${this.name}. ${this.age} years old. ${weight} kg.`
)
const yamada = new Human({name:'Taro Yamada', age:12, weight:62.5})
const suzuki = Human.of({name:'Itiro Suzuki', age:24, weight:80.2})
```

```javascript
const Human = new Class({
    name: new Field('String', {
        get(){return `${this.firstName} ${this.firstName} ${this.lastName}`},
        set(v){[this.firstName, this.firstName]=v.split(' ')},
    }),
    firstName : new Field('String'), 
    lastName : new Field('String'), 
    age: new Field('Integer', 0, false, true), 
    intro() { return `My name is ${this.name}. ${this.age} years old.` },
})
const yamada = new Human({name:'Taro Yamada', age:12})
const suzuki = new Human({name:'Itiro Suzuki', age:24})
const yamada = Human.of({name:'Taro Yamada', age:12})
const suzuki = Human.of({name:'Itiro Suzuki', age:24})
```

